### Offer 
+ [Fibonacci](https://github.com/jikwjjw/Java_Mask/blob/SwordOffice/Fibonacci.java)：斐波那契数列两种实现方法，自顶向上和自顶向下
+ [JumpFloorII](https://github.com/jikwjjw/Java_Mask/blob/SwordOffice/JumpFloorII.java)：青蛙跳，转化成数列
---------------
+ [找到两个排序数组的中位数](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/FMSA.java)：排序,双指针
+ [二分查找法查找某字符](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/Search.java)
---------------------
+ [组合数字](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86%E5%92%8C%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%97/LetterCombinations.java)：深度遍历和组合数字
+ [找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/CombinationSum3.java)
+ [给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/CombinationSum.java):递归回溯
+ [给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/FindSubstring.java)
+ [字母全排列](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/%E5%85%A8%E6%8E%92%E5%88%97.java)
----------------------------------------
+ [给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/IsValid.java)
+ [字符串节码](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/DecodeString.java)：栈
+ [数独有效](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/IsValidSudoku.java)
+ [约瑟夫环](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/Joseph.java)
+ [寻找重复数字](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/FindDuplicate.java):按照环形列表的思想做
+ [给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/RemoveDuplicates.java)
+ [0～n-1中缺失的数字](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/SearchII.java):边界条件判断
+ [给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/StrStr.java)
+ [前K个高频元素](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/TopKFrequent.java): map统计，转化成大根堆统计
+ [最大值更替](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/maxSubArray.class)
+ [和为s的两个数字](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/twoSum.java):双指针
+ [和为s的两个数字II](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/FindContinuousSequence.java):滑动窗口
+ [移动零](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/MoveZeroes.java):双指针，快排思想
------------------------------------------------

+ [丑数](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/NthUglyNumber.class):动态规划
+ [返回杨辉三角的第 k 行](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/GetRow.java) ：动态规划
+ [三角形最小路径和](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/MinimumTotal.java): 动态规划，缩减滚动一维数组
+ [打家劫舍，隔一个取和](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/Rob.java):动态规划
+ [打家劫舍III,树有关](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/RobIII.java): 左右子树 + 动态规划
+ [完全平方数](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/NumSquares.java): 动态规划
+ [机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/UniquePaths.java)动态规划
+ [现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/UniquePathsWithObstacles.java)
+ [给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/MinPathSum.java)
+ [最长上升子序列](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/LengthOfLIS.java):动态规划
+ [零钱兑换](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/CoinChange.java):动态规划
------------------------------------------------
+ [最短回文串：给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。](https://github.com/jikwjjw/Java_Mask_LetCode/blob/SwordOffice/ShortestPalindrome.java)：通过next数组求

